## 1. One system (logistics-aligned, from CallSine)

**Prompt**

> Tell me about a system you built that dealt with real operational constraints.

**Strong answer**

> At CallSine, I worked on a system that scheduled outbound messages and follow-ups
> across email and LinkedIn. Each message had to go out in a specific time window, and 
> there were daily limits on how much could be sent.
>
> Messages could be scheduled, moved, canceled, or retried, and the same request could 
> show up more than once. The system had to handle that without double-sending messages 
> or losing track of capacity.
>
> The hard part wasn’t storing the data. It was keeping the counts and timing correct 
> while still letting plans change.

If interrupted with “what made it hard?”:

> The hard part was making sure that when a message moved, the old slot was fully freed 
> before the new one was taken, so limits never drifted over time.

---

## 2. One failure (from CallSine)

**Prompt**

> Tell me about something that broke in production.

**Strong answer**

> We had a bug where rescheduling messages slowly pushed them further into the future 
> than necessary, even though earlier slots were available. Nothing crashed, but delivery 
> timing drifted over time.
>
> I tracked it down by logging every time a message’s scheduled date changed, not just 
> the final date. That showed me that once a message got pushed forward, later retries 
> kept using that pushed date as their starting point.
>
> I fixed it by making sure that shift only happened once, instead of stacking on every retry.

If pressed:

> The takeaway for me was that time-based bugs don’t usually fail loudly. You have to 
> watch how things change step by step to catch them.

---

## 3. One tradeoff (relevant to Rinse, but from your work)

**Prompt**

> What tradeoff did you make that affected performance or flexibility?

**Strong answer**

> I chose to make message updates very explicit and run them in a straightforward order 
> instead of trying to optimize early with background processing.
>
> That meant the system was a bit slower at first, but it made behavior predictable. Once 
> we trusted that messages and limits stayed in sync, we could safely speed things up.

If asked why that matters:

> In systems that affect real people, it’s better to be slightly slower than to send the 
> wrong thing or break trust.

---

## 4. One ambiguous call (your judgment)

**Prompt**

> Tell me about a decision you made without clear requirements.

**Strong answer**

> There wasn’t a clear rule for how late a scheduled message could be canceled or changed. 
> Instead of guessing, I made those rules strict and consistent across the system.
>
> That meant blocking some edge cases, but it avoided surprises like limits changing 
> underneath users or messages going out unexpectedly.

If they push back:

> It’s easier to relax rules later than to clean up unpredictable behavior after the fact.

---

## Close (how this connects to Rinse)

If the CTO asks how this applies to logistics:

> The patterns are similar. Whether it’s messages or pickups, you’re dealing with time 
> windows, limits, and changes. If you don’t keep those consistent, small errors add up fast.

---
