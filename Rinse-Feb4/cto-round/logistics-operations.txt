## 1. One system (logistics-aligned)

**Prompt**

> Tell me about a system you built that dealt with real operational constraints.

**Strong answer**

> I built a scheduling system that assigned work into specific time windows with a fixed amount of daily capacity.
> Orders could be scheduled, moved, canceled, or retried, and the system had to behave correctly even when the same
> request came in more than once or arrived in an unexpected order.
>
> The tricky part wasn’t the data structures. It was making sure capacity never went negative or got double-counted
> while still letting plans change.

If interrupted with “what made it hard?”:

> The hard part was making sure every change had a clear before and after, so nothing ended up partially applied.

---

## 2. One failure (operations realism)

**Prompt**

> Tell me about a failure that affected operations.

**Strong answer**

> We ran into a bug where moving orders around slowly threw off capacity. Nothing broke outright, but over time the
> system started thinking certain time windows were full when they weren’t.
>
> The issue was that rescheduling tweaked capacity bit by bit instead of treating it as “free the old slot, then
> take a new one.” I fixed it by making rescheduling follow that same two-step process every time.

If pressed:

> The lesson was that small adjustments add up. It’s safer to undo the old thing and redo it cleanly than to try
> to be clever.

---

## 3. One tradeoff (relevant to Rinse)

**Prompt**

> What tradeoff did you make that affected performance or flexibility?

**Strong answer**

> I decided to apply order changes one at a time in a very direct way, even though we could have made parts of it
> faster earlier on.
>
> That meant things were a bit slower at first, but it kept capacity, timing, and order status in sync. Once we
> trusted the system, we could speed it up without worrying about breaking it.

If asked why that matters:

> In logistics, it’s usually better to be slightly slower than to be wrong.

---

## 4. One ambiguous call (real-world ops)

**Prompt**

> Tell me about a decision you had to make without clear requirements.

**Strong answer**

> There wasn’t a clear rule for how late someone could cancel an order. Instead of guessing, I made the rules strict
> and enforced them everywhere.
>
> That meant rejecting some edge cases, but it prevented sudden capacity changes and made the system’s behavior
> predictable for the people using it.

If they push back:

> You can always loosen rules later. Fixing messy behavior after the fact is much harder.

---

## Close (very Rinse-friendly)

If the CTO asks “how do you think about logistics systems?”:

> I think of them like bookkeeping. Every change needs to add up, and the numbers should always match.

